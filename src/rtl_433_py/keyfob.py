#
#    classes for storing bit information
#
#    Copyright (C) 2022 Alfred Daimari
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#

from rf_sender import RfMessage
from rf_sender import RfSender
from rflib import *


class BitPack:
    """
    data structure to hold a row of bits \n
    --- \n

    attributes: \n
    bit_pk - a packet of bits \n
    gap_to_prev_bitpk - gap to the previous bit packet sent \n
    --- \n

    methods: \n
    convert_to_hex() \n
    convert_to_binary() \n
    """

    def __init__(self, bit_string: any, gap_to_prev_bitpk: int) -> None:
        """
        Init BitPacket \n
        :param bit_string: a string of bits, duh!
        :param gap_to_prev_bitpk: gap to previous row in bitbuffer, generated by rtl_433
        """
        self.time_to_prev_bitpk = gap_to_prev_bitpk / 250000
        self.bit_pk = bit_string
        self.__num_type = 2  # numeral system used to represent the bit_pk

    def __len__(self) -> int:
        return len(self.bit_pk)

    def convert_to_hex(self) -> None:
        """
        Converts binary to hex
        """
        if self.__num_type == 2:
            int_rep = int(self.bit_pk, 2)
            hex_rep = hex(int_rep)
            self.bit_pk = hex_rep
            self.__num_type = 16

        if self.__num_type == 10:
            hex_rep = hex(self.bit_pk)
            self.bit_pk = hex_rep
            self.__num_type = 16

    def convert_to_binary(self) -> None:
        """
        Converts to binary
        """
        if self.__num_type == 16:
            int_rep = int(self.bit_pk, 16)
            bin_rep = bin(int_rep)[2:]
            self.bit_pk = bin_rep
            self.__num_type = 2

        if self.__num_type == 10:
            bin_rep = bin(self.bit_pk)[2:]
            self.bit_pk = bin_rep
            self.__num_type = 2

    def convert_to_decimal(self) -> None:
        """
        Converts to decimal
        """
        if self.__num_type == 16:
            int_rep = int(self.bit_pk, 16)
            self.bit_pk = int_rep
            self.__num_type = 10

        if self.__num_type == 2:
            int_rep = int(self.bit_pk, 2)
            self.bit_pk = int_rep
            self.__num_type = 10


class KeyFobPacket:
    """
    data structure to hold a key fob packet \n
    --- \n

    attributes: \n
    packets: instances of BitPackets \n
    packet_status: \n
    0 - packet still not fully formed, still accepting more bits \n
    1 - packet fully formed, not accepting any more bits \n
    --- \n
    """

    def __init__(self, bit_string: str, gap_to_prev_bitpk: int) -> None:
        self.packets = [BitPack(bit_string, gap_to_prev_bitpk)]
        self.packet_status = 0
        self.__set_packet_validity()

    def __len__(self):
        return len(self.packets)

    @property
    def time_to_prev_keyfob(self) -> float:
        """
        get key fob packet distance to previous key fob packet
        """
        return self.time_to_prev_pk(0)

    def time_to_prev_pk(self, ind: int) -> float:
        """
        :param ind: the index of the packet in key fobs
        :return: returns the time to prev packet
        """
        return self.packets[ind].time_to_prev_bitpk

    def __get_packet_validity(self) -> bool:
        return self.packet_status == 1

    def __set_packet_validity(self) -> None:
        """
        check if key fob packet is fully formed or not
        """
        total_bits = 0
        for pk in self.packets:
            total_bits += len(pk)
        if not total_bits < 224:
            self.packet_status = 1  # packet is fully formed, should not allow appending of more bits

    @property
    def complete(self) -> bool:
        """
        :return: if the key fob packet is 'valid' (has a valid length)
        """
        return self.__get_packet_validity()

    def __concatenate(self, key_fb_pkt) -> bool:
        """
        validate and concatenate to key fob packets together
        """
        if not isinstance(key_fb_pkt, KeyFobPacket):
            raise TypeError("key_fb_packet is not an instance of KeyFobPacket")

        if key_fb_pkt.time_to_prev_keyfob < 1200.0:
            self.packets.append(key_fb_pkt.packets[0])
            return True
        else:
            return False

    def concatenate(self, key_fb_pkt) -> bool:
        """
        concatenates two packets if the gap between them is 'very less' \n
        :param key_fb_pkt: An instance of class KeyFobPacket
        :return: bool : whether concatenation was successful or not
        """
        if not self.__get_packet_validity():
            concat_ = self.__concatenate(key_fb_pkt)
            self.__set_packet_validity()
            return concat_
        else:
            return False

    def convert_to_hex(self) -> None:
        """
        Converts bits to hex representation
        """
        for pkt in self.packets:
            pkt.convert_to_hex()

    def convert_to_binary(self) -> None:
        """
        Converts bits to binary representation
        """
        for pkt in self.packets:
            pkt.convert_to_binary()

    def convert_to_decimal(self) -> None:
        """
        Converts bits to decimal representation
        """
        for pkt in self.packets:
            pkt.convert_to_decimal()


class RollingKeyFobs:
    """"
    data structure to hold the rolling key fobs,
    send one out, when the length of data structure is 2
    """

    def __init__(self, dev: object) -> None:
        """
        :param dev: rf device
        """
        self.key_fobs_list = []
        if not isinstance(dev, RfSender):
            raise TypeError("dev is not an instance of RfSender")
        self.dev = dev

    def __len__(self):
        return len(self.key_fobs_list)

    @property
    def dispatchable(self) -> bool:
        """
        checks if there are two valid key fobs \n
        and if the previous one can be sent or not
        """
        if len(self) > 1:
            if self.key_fobs_list[0].complete and self.key_fobs_list[1].complete:
                return True
            else:
                self.__shift()
                return self.dispatchable
        else:
            return False

    def __shift(self):
        """
        remove the first element from key fob
        """
        return self.key_fobs_list.pop(0)

    def __send(self, msg: object) -> None:
        """
        send a message using the yardstick
        :param msg: instance of key fob packet
        """
        rf_message = RfMessage(msg, MOD_2FSK | MANCHESTER, 4000, 230, self.dev)
        rf_message.send()

    def push(self, bit_string: str, gap_to_prev_bitpk: int) -> None:
        """
        add a new key fob to list or concatenate with previous key fob \n
        :param bit_string: a string of bits
        :param gap_to_prev_bitpk: gap to the previous received string of bits
        """
        tmp_keyfob_pkt = KeyFobPacket(bit_string, gap_to_prev_bitpk)
        apnd_bool = False

        if len(self.key_fobs_list) > 0:
            lst_key_fob = self.key_fobs_list[-1]
            apnd_bool = lst_key_fob.concatenate(tmp_keyfob_pkt)

        if not apnd_bool:
            self.key_fobs_list.append(tmp_keyfob_pkt)

        if self.dispatchable:
            keyfob_tb_snt = self.__shift()
            self.__send(keyfob_tb_snt)
            del keyfob_tb_snt
