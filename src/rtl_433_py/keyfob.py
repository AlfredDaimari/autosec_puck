#
#    classes for storing bit information
#
#    Copyright (C) 2022 Alfred Daimari
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#

from rflib import *


class BitPack:
    """
    data structure to hold a row of bits \n
    --- \n

    attributes: \n
    bit_pk - a packet of bits \n
    gap_to_prev_bitpk - gap to the previous bit packet sent \n
    --- \n

    methods: \n
    convert_to_hex() \n
    convert_to_binary() \n
    convert_to_binary() \n
    """

    def __init__(self, bit_string: any, gap_to_prev_bitpk: int) -> None:
        """
        Init BitPacket \n
        :param bit_string: a string of bits, duh!
        :param gap_to_prev_bitpk: gap to previous row in bitbuffer, generated by rtl_433
        """
        self.time_to_prev_bitpk = gap_to_prev_bitpk / 250000
        self.bit_pk = bit_string
        self.__num_type = 2  # numeral system used to represent the bit_pk

    def __str__(self):
        return self.bit_pk

    def __len__(self) -> int:
        return len(self.bit_pk)

    def convert_to_hex(self) -> None:
        """
        Converts binary to hex
        """
        if self.__num_type == 2:
            int_rep = int(self.bit_pk, 2)
            hex_rep = hex(int_rep)
            self.bit_pk = hex_rep
            self.__num_type = 16

        if self.__num_type == 10:
            hex_rep = hex(self.bit_pk)
            self.bit_pk = hex_rep
            self.__num_type = 16

    def convert_to_binary(self) -> None:
        """
        Converts to binary
        """
        if self.__num_type == 16:
            int_rep = int(self.bit_pk, 16)
            bin_rep = bin(int_rep)[2:]
            self.bit_pk = bin_rep
            self.__num_type = 2

        if self.__num_type == 10:
            bin_rep = bin(self.bit_pk)[2:]
            self.bit_pk = bin_rep
            self.__num_type = 2

    def convert_to_decimal(self) -> None:
        """
        Converts to decimal
        """
        if self.__num_type == 16:
            int_rep = int(self.bit_pk, 16)
            self.bit_pk = int_rep
            self.__num_type = 10

        if self.__num_type == 2:
            int_rep = int(self.bit_pk, 2)
            self.bit_pk = int_rep
            self.__num_type = 10


class KeyFobPacket:
    """
    data structure to hold a key fob packet \n
    --- \n

    attributes: \n
    packets: instances of BitPackets \n
    pk_recv_time: the time received (unix time ns format)
    """

    def __init__(self, key_bits: list, car_name: str, pk_recv_time: int) -> None:
        self.name = car_name
        self.packets = [BitPack(b.split(':')[0], int(b.split(':')[1])) for b in key_bits]
        self.pk_recv_time = pk_recv_time

    def __len__(self):
        return len(self.packets)

    def __str__(self):
        str_ = ""
        for s in self.packets:
            str_ += s.__str__()
        return str_

    @classmethod
    def are_same(cls, key_fb1: object, key_fb2: object) -> bool:
        """
        pointless !!
        """
        if (not isinstance(key_fb1, KeyFobPacket)) or (not isinstance(key_fb2, KeyFobPacket)):
            raise TypeError('key_fb1 or key_fb2 are not instances of KeyFobPacket')

        return False

    def time_to_prev_bchunk(self, ind: int) -> float:
        """
        :param ind: the index of the packet in key fobs
        :return: returns the time to prev packet
        """
        return self.packets[ind].time_to_prev_bitpk

    def convert_to_hex(self) -> None:
        """
        Converts bits to hex representation
        """
        for pkt in self.packets:
            pkt.convert_to_hex()

    def convert_to_binary(self) -> None:
        """
        Converts bits to binary representation
        """
        for pkt in self.packets:
            pkt.convert_to_binary()

    def convert_to_decimal(self) -> None:
        """
        Converts bits to decimal representation
        """
        for pkt in self.packets:
            pkt.convert_to_decimal()

    def get_conc_pkt(self) -> str:
        """
        :return: string of concatenated bits
        """
        pkt = ''
        for bpk in self.packets:
            pkt += bpk.bit_pk
        return pkt
